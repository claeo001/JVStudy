# JAVA 스터디 1 주차

## 이것이 자바다 
### 프로그램 언어
> - 고급언어 [소스파일]
> - 저급언어 [어셈블리어]
> 
>  - 사람이 이해하기 쉬운 - 고급언어
>  - 컴퓨터가 이해하기 쉬운 - 저급언어

### JAVA?
> - 운영체제 여부 상관없이 실행가능
> - 객체지향 프로그램
> - 메모리 자동정리
> - 무료 라이브러리 풍부
>   
>  - 자바의 소스파일 확장명 = .java
>  - 컴파일 소스파일 확장명 = .class
>  
>       - (운영체제 상관없이 똑같음)
>       - but 설치하는 법은 다름

### 변수 _variable_

> - 메모리에 데이터 저장하는 방법과 규칙을 정하기 위해 사용
> - 하나의 값을 저장할 수 있는 메모리 번지
> 
>   - 같은 타입 같은 값만 가능. 
> > ex)\
> float a = 10f; o\
> int a = 10f; x 
> 
> 변수 명은 첫 글자는 소문자가 와야함.
> 캐멀 스타일로 작성하는게 관례.
> > - 캐멀스타일
> > 
> >   -  여러 단어가 섞일경우 대문자로 구분한다.

> ##### #클래스명은 대문자 변수명은 소문자로 시작한다.

### Primitive Type (기본 타입)

 - 기본 타입은 8개 이며 __[byte, char, short, int, long, float, double, boolean]__
 - 정수형, 실수형, 논리형으로 구분된다.

| 타입    | 메모리크기 | 저장되는 값의 허용범위                                                |
|-------|-------|-------------------------------------------------------------|
| byte  | 1byte | -128 ~127                                                   |
| short | 2byte | -32,768~32,767                                              |
| char  | 2byte | 0~65535(유니코드)                                               |
| int   | 4byte | -2,147,483,648~2,147,483,647                                |
| long  | 8byte | -9,223,372,036,854,775,808 ~<br/> 9,223,372,036,854,775,807 |

 - 1byte = 8 bit 
 - 값의 허용범위보단 메모리크기를 알고 있는 것이 좋다.

 - 문자 타입
>    - 문자 타입은 유니코드로 변환되 저장이 되며 각국의 문자 0~65535 숫자로 매핑한 국제 표준 규약이다. 이러한 문자를 저장 할 수 있도록 char 타입을 제공
>    - '' 이점은 컴파일 에러가 생겨 안에 공백을 추가 해줘야함.
 - 실수 타입
> -  float, double 이 있으며 32bit 64bit == 4byte 8byte에 메모리 크기를 가진다
> -  두 가지의 값의 허용 범위가 다르며 float < double
> -  float 소수 7자리만 정확하며 double 15자리까지 정확하다
> -  정밀한 작업이 필요할경우 double 타입을 사용하면 된다.
> -   java 자체는 기본적으로 double타입으로 간주하기에 float를 사용하려면 접미어 f 를 입력해야한다.
 - 논리 타입
> -  true false 비교 및 논리 연산의 산출값으로 주로 사용

 - 문자열 타입
> -  " 사용, String 타입을 사용한다.
> -  문자열 내에 역슬래시(\) 문자 사용 -> 이스케이프 문자 사용[특정 문자, 출력에 영향].
> -  폰트로 인해 \ 표현이 다를 수 있지만 상관없다.
>> -  (Java 13 이후) *** 를 사용해 블록 문법을 제공한다.
>> -   *** 사용하면 문자열 그대로 표출해줘서 이스케이프 라인피드를 사용할 필요가 없다.
>> -  (Java 14 이후) 텍스트 불록은 \n으로 표현한다.
>> -   줄바꿈을 안하고 이어서 작성하려면 끝에 \를 붙이면 된다.

 - 자동 타입 변환
> -  작은 타입을 큰 타입 범위에 저장할 때 자동으로 변환을 한다.
> -  byte < short, char < int < long < float < double
> -  정수 타입을 실수 타입으로 대입할 때 무조건 타입 변환이 됨.
 - 강제 타입 변환 (__casting__)
> -   큰 타입을 작은 타입에 변환할 때 사용 -> 연산자() 괄호 안에는 타입을 쪼대는 단위
> -   타입 범위내에 초과가 되면 데이터가 누락됨.
> - 연산식 자동 타입변환
> -  서로 다른 연산식에 대한 값이 있을 경우 더 큰 타입으로 자동 형변환 되며 정수 실수 끼리 연산식 진행시에는 실수형으로 표현이 된다.
> -  실수타입에 정수형 연산식을 대입하면 정수결과가 나오며 이때는 실수타입으로 형변환을 해줘야 원하는 값이 나온다.
 - 문자열 기본 타입 변환
> -  String -> 기본형 타입 변환
> -  == 타입별 정의 = 타입.parse타입(문자열); 표현하며
> - 기본형 -> String 변환시에는
> -  String.valueOf(기본타입값) 메소드를 이용한다
 - 변수 사용 범위
> -  블록 별로 나뉘어 있으며 특정 범위에서 사용하고 싶으면 블록내부에 선언하며 메소드 전체에 사용은 메소드 내에 선언한다.
 - 콘솔 출력
> -  System.out.println/ print / printf 등이 있으며
> -  printf 명을 사용할때는 형식화된 문자열을 표현할 수 있다.
> - 키보드 입력 데이터 변수 저장
> -  Scanner 타입 변수를 사용하며 이때는 import 문을 사용해야하며 Enter를 사용해 데이터를 입력해준다.
> - __기본타입__ 동일한지 비교 시에 == 사용
> - __String타입__ 비교 시에 equals()를 사용한다.

### 연산자 _Operator_
 - 부호 증감 연산자.
> - +, - 주로 부호 변경시 사용 (-) 주로 사용
> - 부호를 변경 시에 타입은 int 이다. -> int 타입 변수에 대입을 해야함
> - ++ -- 변수의 값 1을 증가 감소 시킨다.
> - 증감 연산자가 앞에 있으면 우선 변수를 변환하고 연산 수행을 하며 뒤에 있으면 모든 연산을 끝낸 후에 변환함.
 - 산술 연산자
> - +, -, *, /, % = 총 5 개
> - 더하기 빼기 곱하기 나누기 나머지로 표현함.
>> - long을 제외한 정수 타입이 연산을 하면 결과는 int 타입 long 연산 시 long 타입 // 연산자 중 실수 타입 포함 시 결과는 실수 타입.
- 오버플로우 언더플로우
> - 타입의 최대 허용값 벗어나면 오버플로우 최솟값을 벗어나면 언더플로우 라고 말한다.
> - 실행시에 에러는 발생 안함 _but_ 벗어나면 최소값, 최대값으로 돌아간다.
> - 발생시에 타입을 변환해줘야한다.
- 나눗셈 연산 후 NaN, Infinity 처리 (__예외처리 하는 법__)
> - 무한대의 값은 정수 표현 x -> 표현시 ArithmeticException 발생
> - /, % 결과가 NaN,Infinity 확인 후 다음 연산 수행 한다.
>> - Double.isInfinite(), Double.isNaN()를 사용해 확인한다.
>> - boolen 을 사용해 true false 산출함.
- 비교 연산자
> - 동등 == !=, 크기 < <= > >= 를 사용하며 boolen 타입으로 true false를 산출.
> - 주로 제어문에 사용 -> 조건문 if 반복문 for, while 에서 실행 흐름 제어할 때
> - 실수형은 값의 정밀도에 따라 false를 반환하기에 값 변환을 해줘야한다.
> - 문자열은 동등 연산자 대신 equals()와 !equals()를 사용한다.
- 논리 연산자
> - 논리곱 && 논리합 || 배타적 논리합 ^ 논리 부정 ! 연산을 수행
> - 논리 연산 -> 제어문 반복문에서 주로 사용한다.
>> - && & => 모든 값이 true 시 true ( & 전체 값 확인 후 출력 && 첫 값이 false면 바로 false 산출 )
>> - || | => 하나의 값이 true 시 ture ( 위 내용과 동일 )
>> - ^ => 두개 의 값이 true false 반환시 true
>> - ! => 피연산자의 논리값을 바꿈 (true 시 false 반환)

# 자바 스터디 2주차
 - 비트 논리 연산자
> - bit 단위로 수행 -> 정수 타입만 가능 실수는 부동소수점이기에 불가능.
> - 피연산자와 산출 결과가 1, 0 이라는 점에 주목을 하며 1은 true 0은 false를 나타낸다. [논리 연산자와 같다]
 - 비트 이동 연산자
> - << >> >>> 이렇게 세가지를 나타내며 방향에 표시된 곳으로 이동을 하며 a는 기준점 b 는 이동 수를 나타낸다.
 - 대입 연산자
> - 우측의 값을 좌측에 피연산자 변수에 대입을 하는 의미이며 단순 대입과 복합 대인 연산자가 있다
> - 단순 대입은 '=' 복합 대입은 '+= -= *= /= %= &= |= ^= <<= >>= >>>=' 이 존재한다.
 - 삼항(조건) 연산자
> - 3개의 피연산자를 가지며 ? 앞의 피연산자는 boolean 아니면 조건식 형태가 와서 조건연산자라고도 한다.

### 제어 [조건문, 반복문]
- 코드 실행 흐름 제어
> - 코드 실행은 위에서 아래로 흐르며 각 중괄호({}) 흐름이 진행된다. 제어문에 따라 다양한 실행 흐름이 생성되는 점도 있다.
> - 제어문에는 조건문과 반복문이 있다.
> - 반복문일 경우 처음으로 다시 돌아가 반복 실행을 하는것을 루핑이라고 한다.
> - 제어문 블록 내에서도 또다른 제어문을 사용할 수 있어 복잡한 흐름 제어도 가능하다.
- 조건문 [if, swich]
> - 중괄호 블록은 생략하지 않고 작성하는 것을 추천하며 이유는 가독성이 낮아지며 버그 발생원인 이 된다.
> - [ 조건문과 상관없게 되는 식이 발생할 수 있다. ] 
 - if(조건식)
> - 조건식 안에는 참, 거짓을 산출하는 연산식이나 boolean 변수가 온다. 참이면 실행하고 거짓이면 안한다.
> - 거짓일 때 실행을 하려면 else 블록을 추가를 할 수 있다.
> - 임의의 정수를 뽑기 위해 Math.random() 메서드를 활용한다.
> - if 블록 내부에 또다른 if 문을 사용할 경우 이 것을 중첩 if 문이라고 부르며 중첩의 단계는 제한이 없다.
> - 경우의 수가 많아지면 else if문을 반복적 추가로 코드가 복잡해진다
 - switch
> - 변수의 값에 따라 실행을 해서 if else 문보다 코드가 간결해진다.
> - 변수의 값에 해당하는 case로 가서 실행문을 실행시킨다 해당하는 값이 없을 경우에는 default로 실행문을 실행한다. 이 경우 필요가 없을시 생략이 가능하다.
> - (Java 12 이후) Expressions 를 사용할 수 있다. break 문을 없애고 화살표와 중괄호를 사용한다.
>  - switch(grade){
>  -  case 'A':
>  -   System.out.println("우수 회원임");
>  -   break;}
> - 위 코드를 Expression 을 사용 하면
>  - switch(grade) {
>  -  case 'A' -> {
>  -   System.out.println("우수 회원임");}
>  - 중괄호 안에 실행문이 하나만 있으면 생략이 가능함.    
> - 위와 방식처럼 표현하며 코드 가독성이 좋아진다.
 - for
> - 똑같은 실행문을 반복적으로 실핼할 경우에 사용한다.
> - for(초기화식 조건식 증감식) { 실행문 } 으로 진행한다
> - 조건식이 거짓이 될때까지 반복 실행을 한다.
> - 초기화식에서 선언된 변수는 for문 안에 사용하는 로컬 변수라서 벗어나서 사용할 시에 for문 이전에 선언해야한다.
 - while
> - for문은 정해진 횟수만큼 한다면 while은 조건식이 참일 때 반복한다. 거짓이 되면 반복문은 종료가 된다.
> - whelie(조건식){ 실행문 }
> - 조건식에 참을 실행한다면 무한루트에 빠질 수 있다. 빠져나가기 위한 코드가 필요하다.
> - if문을 사용해서 재정의를 통해 빠져나갈 수 있다
 - do-while
> - do { 실행문 } while (조건식);
> - 실행문이 실행한 뒤 조건식을 평가하며 결과가 참일 경우만 반복한다.
> - do while 문 같은 경우에는 while 마지막에 세미클론(;) 을 넣어야한다.
> - break continue 는 마지막 단에 작성을 하며 조건식에서 나가냐 더 실행하는가로 나뉘며
> - break 를 했을 시 실행을 중지 하거나 조건식 종료를 한다.
> - continue 는 특정 조건에 만족을 할 시에 그 이후 문장을 실행하지 않고 다음 반복으로 넘어간다.
> - continue 는 번호를 나열해 짝수 홀수를 구분하기에 좋다.

## 객체 지향 프로그래밍

### 참조 타입
- 데이터 타입 분류
> - 기본타입 (Primitive type) 참조타입 (Reference type) 두가지로 분류 한다.
> - 참조 타입은 객체의 번지를 참조하는 타입ㅇ미ㅕ 배열, 열거, 클래스, 인터페이스 타입이 있다.
> - 데이터(필드) + 메소드 = 객체
> - 기본과 참조의 차이점은 저장되는 값이다. 기본은 값의 그자체를 저장하고 참조는 객체의 생성된 메모리번지를 저장한다.
> - 변수들은 스택 메모리 영역에 생성이되며 참조 타입 변수는 힙 메모리 영역에 객체 번지를 저장한다. 힙 메모리 번지를 통해 객체를 참조한다.
 - 생성된 객체를 참조 받는 경우에 같은 배열을 참조 받아도 대입되는 번지가 다르다. 불러온 참조값을 새로운 변수에 대입하는 경우에는 같다고 할 수 있다.
 -  null, NullPointerException
> - 참조 타입은 null 값을 가질 수 있다 여기서 null 이란 번지를 갖고 있지 않은 상태로 정의한다.
> - null 값도 초기값 사용 가능해서 초기화된 값은 스택 영역에 생성이 된다. 참조 타입이 null 값을 갖는지 확인 시에 == != 연산을 수행 할 수 있다.
> - 자바는 프로그램 도중 발생하는 오류를 예외(Exception)라고한다.
int[] intArray = null;
intArray[0] = 10; >> NullPointerException
> - NullPointerException 위 코드예시처럼 intArray에 참조하는 배열 객체가 없어 10을 저장할 수 없기 떄문이다.
> - 배열 참조 자체가 null 값이라 그 값은 참조된 값이 없기에 넣을 수 있는 장소가 없기 때문이다.
> - 다음 예시코드는
String str = null;
System.out.println(str.length());
> - str 변수가 참조하는 String 객체가 없으며 문자열의 길이를 구할 수 없기에 NullPointerException이 발생한다.
> - 그래서 앞으로 NullPointerException이 발생하면 그 곳에 null 상태의 참조 변수가 사용하고 있다는 점을 알게 됐다.
> - 해결법은 참조 변수가 객체를 정확하게 참조하도록 번지를 대입해야한다는 해결법을 배웠다.
> - 참조하지 않는 객체는 사용할 수 없는 객체로 구분되며 자바에서는 이러한 객체를 쓰레기 취급을 하며 Garbage Collector를 실행시켜 자동으로 제거시킨다.
> - 자바에서 메모리를 관리해준다는 얘기가 어떤 의미인지 알게 되었다.
> - 코드를 이용해 객체를 제거하는 방법을 제공하지 않아 객체의 모든 참조를 제거해서 없애는 것이다.
- 문자열(String) 타입
> -  
